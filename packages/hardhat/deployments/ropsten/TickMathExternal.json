{
  "address": "0x0772382Dd7D99adb5218d31fAdfE1c68c8477335",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tick",
          "type": "int24"
        }
      ],
      "name": "getSqrtRatioAtTick",
      "outputs": [
        {
          "internalType": "uint160",
          "name": "sqrtPriceX96",
          "type": "uint160"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtPriceX96",
          "type": "uint160"
        }
      ],
      "name": "getTickAtSqrtRatio",
      "outputs": [
        {
          "internalType": "int24",
          "name": "tick",
          "type": "int24"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x0a80270d637a17744e7d2a1817f02f1b799a8b34bae9e5473ee2c2e07ec60f8a",
  "receipt": {
    "to": null,
    "from": "0x5599b4EAdDd319e2F462b27fC8378B0BFaD309CA",
    "contractAddress": "0x0772382Dd7D99adb5218d31fAdfE1c68c8477335",
    "transactionIndex": 10,
    "gasUsed": "461403",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x411639e2564e56aae9d011a850a25337237649de69a05c62c2dfebbd28d6387f",
    "transactionHash": "0x0a80270d637a17744e7d2a1817f02f1b799a8b34bae9e5473ee2c2e07ec60f8a",
    "logs": [],
    "blockNumber": 12325016,
    "cumulativeGasUsed": "5435106",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "d91027c30078be5bfba0223abd5c6e60",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"name\":\"getSqrtRatioAtTick\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"}],\"name\":\"getTickAtSqrtRatio\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getSqrtRatioAtTick(int24)\":{\"details\":\"Throws if |tick| > max tick\",\"params\":{\"tick\":\"The input tick for the above formula\"},\"returns\":{\"sqrtPriceX96\":\"A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0) at the given tick\"}},\"getTickAtSqrtRatio(uint160)\":{\"details\":\"Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may ever return.\",\"params\":{\"sqrtPriceX96\":\"The sqrt ratio for which to compute the tick as a Q64.96\"},\"returns\":{\"tick\":\"The greatest tick for which the ratio is less than or equal to the input ratio\"}}},\"stateVariables\":{\"MAX_SQRT_RATIO\":{\"details\":\"The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\"},\"MAX_TICK\":{\"details\":\"The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\"},\"MIN_SQRT_RATIO\":{\"details\":\"The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\"},\"MIN_TICK\":{\"details\":\"The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\"}},\"title\":\"Math library for computing sqrt prices from ticks and vice versa\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getSqrtRatioAtTick(int24)\":{\"notice\":\"Calculates sqrt(1.0001^tick) * 2^96\"},\"getTickAtSqrtRatio(uint160)\":{\"notice\":\"Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\"}},\"notice\":\"Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2**-128 and 2**128\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libs/TickMathExternal.sol\":\"TickMathExternal\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"contracts/libs/TickMathExternal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMathExternal {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) public pure returns (uint160 sqrtPriceX96) {\\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        require(absTick <= uint256(MAX_TICK), \\\"T\\\");\\n\\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) external pure returns (int24 tick) {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \\\"R\\\");\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n    }\\n}\\n\",\"keccak256\":\"0xfd917bc787958baa0b7fd6f526f88a63a5b98a32d3ff1c0f67665e7a1be86e10\",\"license\":\"GPL-2.0-or-later\"}},\"version\":1}",
  "bytecode": "0x610768610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c80634f76c05814610045578063986cfba314610082575b600080fd5b61006b6004803603602081101561005b57600080fd5b50356001600160a01b03166100be565b6040805160029290920b8252519081900360200190f35b6100a26004803603602081101561009857600080fd5b503560020b6103f3565b604080516001600160a01b039092168252519081900360200190f35b60006401000276a36001600160a01b038316108015906100fa575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038316105b61012f576040805162461bcd60e51b81526020600482015260016024820152602960f91b604482015290519081900360640190fd5b77ffffffffffffffffffffffffffffffffffffffff00000000602083901b166fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c979088119617909417909217179091171717608081106101d957607f810383901c91506101e3565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d607f198f0160401b60c09190911c678000000000000000161760c19b909b1c674000000000000000169a909a1760c29990991c672000000000000000169890981760c39790971c671000000000000000169690961760c49590951c670800000000000000169490941760c59390931c670400000000000000169290921760c69190911c670200000000000000161760c79190911c670100000000000000161760c89190911c6680000000000000161760c99190911c6640000000000000161760ca9190911c6620000000000000161760cb9190911c6610000000000000161760cc9190911c6608000000000000161760cd9190911c66040000000000001617693627a301d71055774c8581026f028f6481ab7f045a5af012a19d003aa9198101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b146103e457886001600160a01b03166103c8826103f3565b6001600160a01b031611156103dd57816103df565b805b6103e6565b815b9998505050505050505050565b60008060008360020b1261040a578260020b610412565b8260020b6000035b9050620d89e8811115610450576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b60006001821661047157700100000000000000000000000000000000610483565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff16905060028216156104b7576ffff97272373d413259a46990580e213a0260801c5b60048216156104d6576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b60088216156104f5576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b6010821615610514576fffcb9843d60f6159c9db58835c9266440260801c5b6020821615610533576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615610552576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615610571576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615610591576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b6102008216156105b1576ff987a7253ac413176f2b074cf7815e540260801c5b6104008216156105d1576ff3392b0822b70005940c7a398e4b70f30260801c5b6108008216156105f1576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615610611576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615610631576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615610651576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615610671576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615610692576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b620200008216156106b2576e5d6af8dedb81196699c329225ee6040260801c5b620400008216156106d1576d2216e584f5fa1ea926041bedfe980260801c5b620800008216156106ee576b048a170391f7dc42444e8fa20260801c5b60008460020b131561070957806000198161070557fe5b0490505b64010000000081061561071d576001610720565b60005b60ff16602082901c019250505091905056fea26469706673582212202e5ff2dd11e1c84c4b4e2364d3ed76b64538bfce96b28ff3a83052ea235fa8ed64736f6c63430007060033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c80634f76c05814610045578063986cfba314610082575b600080fd5b61006b6004803603602081101561005b57600080fd5b50356001600160a01b03166100be565b6040805160029290920b8252519081900360200190f35b6100a26004803603602081101561009857600080fd5b503560020b6103f3565b604080516001600160a01b039092168252519081900360200190f35b60006401000276a36001600160a01b038316108015906100fa575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038316105b61012f576040805162461bcd60e51b81526020600482015260016024820152602960f91b604482015290519081900360640190fd5b77ffffffffffffffffffffffffffffffffffffffff00000000602083901b166fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c979088119617909417909217179091171717608081106101d957607f810383901c91506101e3565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d607f198f0160401b60c09190911c678000000000000000161760c19b909b1c674000000000000000169a909a1760c29990991c672000000000000000169890981760c39790971c671000000000000000169690961760c49590951c670800000000000000169490941760c59390931c670400000000000000169290921760c69190911c670200000000000000161760c79190911c670100000000000000161760c89190911c6680000000000000161760c99190911c6640000000000000161760ca9190911c6620000000000000161760cb9190911c6610000000000000161760cc9190911c6608000000000000161760cd9190911c66040000000000001617693627a301d71055774c8581026f028f6481ab7f045a5af012a19d003aa9198101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b146103e457886001600160a01b03166103c8826103f3565b6001600160a01b031611156103dd57816103df565b805b6103e6565b815b9998505050505050505050565b60008060008360020b1261040a578260020b610412565b8260020b6000035b9050620d89e8811115610450576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b60006001821661047157700100000000000000000000000000000000610483565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff16905060028216156104b7576ffff97272373d413259a46990580e213a0260801c5b60048216156104d6576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b60088216156104f5576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b6010821615610514576fffcb9843d60f6159c9db58835c9266440260801c5b6020821615610533576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615610552576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615610571576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615610591576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b6102008216156105b1576ff987a7253ac413176f2b074cf7815e540260801c5b6104008216156105d1576ff3392b0822b70005940c7a398e4b70f30260801c5b6108008216156105f1576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615610611576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615610631576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615610651576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615610671576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615610692576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b620200008216156106b2576e5d6af8dedb81196699c329225ee6040260801c5b620400008216156106d1576d2216e584f5fa1ea926041bedfe980260801c5b620800008216156106ee576b048a170391f7dc42444e8fa20260801c5b60008460020b131561070957806000198161070557fe5b0490505b64010000000081061561071d576001610720565b60005b60ff16602082901c019250505091905056fea26469706673582212202e5ff2dd11e1c84c4b4e2364d3ed76b64538bfce96b28ff3a83052ea235fa8ed64736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getSqrtRatioAtTick(int24)": {
        "details": "Throws if |tick| > max tick",
        "params": {
          "tick": "The input tick for the above formula"
        },
        "returns": {
          "sqrtPriceX96": "A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0) at the given tick"
        }
      },
      "getTickAtSqrtRatio(uint160)": {
        "details": "Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may ever return.",
        "params": {
          "sqrtPriceX96": "The sqrt ratio for which to compute the tick as a Q64.96"
        },
        "returns": {
          "tick": "The greatest tick for which the ratio is less than or equal to the input ratio"
        }
      }
    },
    "stateVariables": {
      "MAX_SQRT_RATIO": {
        "details": "The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)"
      },
      "MAX_TICK": {
        "details": "The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128"
      },
      "MIN_SQRT_RATIO": {
        "details": "The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)"
      },
      "MIN_TICK": {
        "details": "The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128"
      }
    },
    "title": "Math library for computing sqrt prices from ticks and vice versa",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getSqrtRatioAtTick(int24)": {
        "notice": "Calculates sqrt(1.0001^tick) * 2^96"
      },
      "getTickAtSqrtRatio(uint160)": {
        "notice": "Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio"
      }
    },
    "notice": "Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2**-128 and 2**128",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}